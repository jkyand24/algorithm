# ------------------------------ 내 풀이 (00:28~00:40): 정답 BUT 시간복잡도 너무 큼 

# n이 2 이상이라는 조건이 있으므로, "-1" 보다는 "/2"가 무조건 더 빠르게 작아짐 -> "/2"가 되는지 먼저 확인하고, 되면 이걸 수행 

n, k = map(int, input().split())

res = n
cnt = 0

while res != 1:
    if (res % k == 0): # 나눠 떨어지면
        res = res // k
    else:
        res = res - 1
    cnt += 1

print(cnt)

# ------------------------------ 모범 코드

# N, K공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())

result = 0

while True:
    # 1. N이 K로 나누어 떨어지는 수가 될 때까지만 1씩 빼기 (단, N이 K의 배수인 게 아니라 N < K로 될 수도 있음)
    target = (n // k) * k
    result += (n - target)
    n = target

    # 2. K로 나누기
    ## N < K인 경우면 멈추기 
    if n < k:
        break

    ## 이제 정말로 K로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)

print(result)

# ------------------------------ 배운 점 

# 시간복잡도를 고려해야 함. 
# 이를 위해서, 문제를 잘 파악한 후, 단순 구현을 넘어서, 뭔가 반복되는 동작이 있다면 묶어서, 반복문 반복 횟수를 줄이기 

# 시간복잡도 분석에서는 보통 반복문 실행 횟수를 기준으로 함. 
# 각 반복에서 수행되는 기본 연산들은 상수 시간이므로 전체 복잡도에는 영향을 주지 않기 때문